class CondBr {
    in: {
        label: Label,
        csr:   PState,
    },
    insts: [ BCond, BCCond ],
    props: {
        cond: MirCondFlag = MirCondFlag::AL;
    }
}

// Unconditional branches, which do not depend on any condition flags.
template[TargetT] UnCondBranches {
    in: { target: TargetT };
    impl {
        [Label] => UncondBr { insts: [B], },
        [GPR64] => BReg     { insts: [Br, Ret], },
    }
}

template[TargetT] BranchLinks {
    in: { target: TargetT, },
    out: { ra: GPR64, };
    impl {
        [Label]  => BLinkLabel { insts: [ BLink ], },
        [Global] => BLinkGlobal { insts: [ BLinkGlobal ], },
        [GPR64]  => BLinkReg   { insts: [ BLinkReg ], },
    }
}

class CBZs {
    in: {
        cond: GPR64,
        target: Label,
    },
    insts: [ CBZ, CBNZ ],
}

template[Reg] TBZs {
    in: {
        cond: Reg,
        bits: Imm32,
        target: Label,
    };
    impl {
        [GPR64] => TBZ64 { insts: [ TBZ64, TBNZ64 ], },
        [GPR32] => TBZ32 { insts: [ TBZ32, TBNZ32 ], },
    }
}

extern class MirCall;
extern class MirReturn;
extern class MirSwitch;
extern class MirSaveRegs;
extern class MirRestoreRegs;
extern class MirRestoreHostRegs;
extern class MirGEP;
// 啊对, MIR 的注释也是指令 -- 只不过大多数时候什么都不做.
extern class MirComment;
extern class MirCommentedInst;

template[Lhs, Rhs] CompareInsts {
    in: {
        rn:  Lhs,
        rhs: Rhs,
    },
    out: { csr: PState, }
    ;
    impl {
        [GPR64, GPR64] => ICmp64R {
            insts: [ ICmp64R, ICmn64R ],
            props: {
                rm_op: Option<RegOP> = None;
            }
        },
        [GPR32, GPR32] => ICmp32R {
            insts: [ ICmp32R, ICmn32R ],
            props: {
                rm_op: Option<RegOP> = None;
            }
        },

        [GPR64, ImmCalc] => ICmp64I { insts: [ ICmp64I, ICmn64I ], },
        [GPR32, ImmCalc] => ICmp32I { insts: [ ICmp32I, ICmn32I ], },

        [FPR32, FPR32] => FCmp32 { insts: [ FCmp32, FCmpE32 ], },
        [FPR64, FPR64] => FCmp64 { insts: [ FCmp64, FCmpE64 ], },
    }
}

template[Lhs, Rhs] CondCmpInsts {
    in: {
        rn:   Lhs,
        rhs:  Rhs,
    },
    out: { csr: PState, },
    props: {
        cond: MirCondFlag = MirCondFlag::AL;
        nzcv: NZCV = NZCV::empty();
    },
    ;
    impl {
        [GPR64, GPR64] => ICCmp64R { insts: [ ICCmp64R, ICCmn64R ], },
        [GPR32, GPR32] => ICCmp32R { insts: [ ICCmp32R, ICCmn32R ], },
        [GPR64, ImmCCmp] => ICCmp64I { insts: [ ICCmp64I, ICCmn64I ], },
        [GPR32, ImmCCmp] => ICCmp32I { insts: [ ICCmp32I, ICCmn32I ], },
        [FPR32, FPR32] => FCCmp32 { insts: [ FCCmp32, FCCmpE32 ], },
        [FPR64, FPR64] => FCCmp64 { insts: [ FCCmp64, FCCmpE64 ], },
    }
}

template[D, L, R] BinaryOP {
    out: { rd: D, },
    in: { rn: L, rm: R, };

    impl {
        /* 无立即数的二元操作 */

        [GPR64, GPR64, GPR64] => Bin64R {
            insts: [
                Add64R, Sub64R, SMax64R, SMin64R, UMax64R, UMin64R,
                And64R, Bic64R, EON64R, EOR64R, ORR64R, ORN64R,
                Asr64R, Lsr64R, Lsl64R, Ror64R,
                Mul64, MNeg64, SDiv64, UDiv64, SMulH, UMulH
            ],
            props: {
                rm_op: Option<RegOP> = None;
            },
        },
        [GPR32, GPR32, GPR32] => Bin32R {
            insts: [
                Add32R, Sub32R, SMax32R, SMin32R, UMax32R, UMin32R,
                And32R, Bic32R, EON32R, EOR32R, ORR32R, ORN32R,
                Asr32R, Lsr32R, Lsl32R, Ror32R,
                Mul32, MNeg32, SDiv32, UDiv32
            ],
            props: {
                rm_op: Option<RegOP> = None;
            },
        },

        [GPR64, GPR32, GPR32] => MulL {
            insts: [ SMULL, UMULL, SMNegL, UMNegL ],
        },

        /* 带有立即数的二元操作 */

        [GPR64, GPR64, ImmCalc] => Bin64RC { insts: [ Add64I, Sub64I ] },
        [GPR32, GPR32, ImmCalc] => Bin32RC { insts: [ Add32I, Sub32I ] },
        [GPR64, GPR64, Symbol] => Bin64RSym { insts: [ Add64Sym, Sub64Sym ], },

        [GPR64, GPR64, ImmLogic] => Bin64RL {
            insts: [ And64I, Bic64I, EON64I, EOR64I, ORR64I, ORN64I ],
        },
        [GPR32, GPR32, ImmLogic] => Bin32RL {
            insts: [ And32I, Bic32I, EON32I, EOR32I, ORR32I, ORN32I ],
        },
        [GPR64, GPR64, ImmSMax] => Bin64RS {
            insts: [ SMax64I, SMin64I ],
        },
        [GPR64, GPR64, ImmUMax] => Bin64RU {
            insts: [ UMax64I, UMin64I ],
        },
        [GPR32, GPR32, ImmSMax] => Bin32RS {
            insts: [ SMax32I, SMin32I ],
        },
        [GPR32, GPR32, ImmUMax] => Bin32RU {
            insts: [ UMax32I, UMin32I ],
        },
        [GPR64, GPR64, ImmShift] => Bin64RShift {
            insts: [ Asr64I, Lsr64I, Lsl64I, Ror64I ],
        },
        [GPR32, GPR32, ImmShift] => Bin32RShift {
            insts: [ Asr32I, Lsr32I, Lsl32I, Ror32I ],
        },

        /* 处理浮点 */

        [FPR64, FPR64, FPR64] => BinF64R {
            insts: [ FAdd64, FDiv64, FMul64, FNMul64, FSub64 ],
        },
        [FPR32, FPR32, FPR32] => BinF32R {
            insts: [ FAdd32, FDiv32, FMul32, FNMul32, FSub32 ],
        },
    }
}

template[T] MirCopy {
    in: { src: Any, },
    out: { dst: T, } ;

    impl {
        // MIR 伪指令: 拷贝一个操作数到另一个虚拟寄存器里, 保持二进制布局不变.
        [GPR64] => MirCopy64  { insts: [ MirCopy64 ], },
        [GPR32] => MirCopy32  { insts: [ MirCopy32 ], },
        [FPR64] => MirFCopy64 { insts: [ MirFCopy64 ], },
        [FPR32] => MirFCopy32 { insts: [ MirFCopy32 ], },
        [PState] => MirPCopy  { insts: [ MirPCopy ], },
    }
}

template[D, T] UnaryOP {
    in: { src: T, },
    out: { dst: D, } ;

    impl {
        [GPR64, GPR64] => Una64R {
            insts: [
                Neg64R, MVN64R, Mov64R, Abs64R, CLS64, CLZ64, CNT64, CTZ64, RBit64,
                LoadStackPosGr64, StoreStackPosGr64
            ],
            props: {
                dst_op: Option<RegOP> = None;
            },
        },
        [GPR32, GPR32] => Una32R {
            insts: [
                Neg32R, MVN32R, Mov32R, Abs32R, CLS32, CLZ32, CNT32, CTZ32, RBit32,
                SXTB32, SXTH32, SXTW32, UXTB32, UXTH32,
                LoadStackPosGr32, StoreStackPosGr32
            ],
            props: {
                dst_op: Option<RegOP> = None;
            },
        },
        [GPR64, GPR32] => ExtR {
            insts: [SXTB64, SXTH64, SXTW64, UXTB64, UXTH64]
        },

        [GPR64, ImmMov] => Mov64I { insts: [ Mov64I ], },
        [GPR64, ImmMovZNK] => MovZNK64 {
            insts: [ MovZ64, MovN64, MovK64 ],
        },
        [GPR32, ImmMov] => Mov32I { insts: [ Mov32I ], },
        [GPR32, ImmMovZNK] => MovZNK32 {
            insts: [ MovZ32, MovN32, MovK32 ],
        },
        [GPR64, Symbol] => Adr    { insts: [ AdrP, Adr ] },

        [FPR64, GPR64] => UnaFG64 { insts: [ FMovFG64, SCvtF64, UCvtF64 ] },
        [GPR64, FPR64] => UnaGF64 {
            insts: [
                FMovGF64,
                // FCvt: AS AU MS MU NS NU PS PU ZS ZU 
                FCvtAS64, FCvtAU64, FCvtMS64, FCvtMU64, FCvtNS64,
                FCvtNU64, FCvtPS64, FCvtPU64, FCvtZS64, FCvtZU64
            ],
        },
        [FPR64, GPR32] => UnaF64G32 { insts: [ SCvtF64G32, UCvtF64G32 ] },

        [FPR32, GPR32] => UnaFG32 { insts: [ FMovFG32, SCvtF32, UCvtF32 ] },
        [FPR32, GPR64] => UnaF32G64 { insts: [ SCvtF32G64, UCvtF32G64 ] },
        [GPR32, FPR32] => UnaGF32 {
            insts: [
                FMovGF32,
                // FCvt: AS AU MS MU NS NU PS PU ZS ZU 
                FCvtAS32, FCvtAU32, FCvtMS32, FCvtMU32, FCvtNS32,
                FCvtNU32, FCvtPS32, FCvtPU32, FCvtZS32, FCvtZU32
            ],
        },

        [GPR64, FPR32] => UnaG64F32 {
            insts: [
                // FCvt: AS AU MS MU NS NU PS PU ZS ZU 
                FCvtAS64F32, FCvtAU64F32, FCvtMS64F32, FCvtMU64F32, FCvtNS64F32,
                FCvtNU64F32, FCvtPS64F32, FCvtPU64F32, FCvtZS64F32, FCvtZU64F32
            ],
        },
        [GPR32, FPR64] => UnaG32F64 {
            insts: [ FCvtAS32F64, FCvtAU32F64 ]
        },

        [FPR64, FPR64] => UnaF64 {
            insts: [
                FMov64R,
                // FRInt: A I M N P X Z
                FRIntA64, FRIntI64, FRIntM64, FRIntN64, FRIntP64, FRIntX64, FRIntZ64,
                FRInt32X64, FRIntZ32X64, FRInt64X64, FRIntZ64X64,
                // Floating Arithmetic with unary source
                FAbs64, FNeg64, FSqrt64,
                // MIR pseudo-instructions
                LoadStackPosF64, StoreStackPosF64
            ],
        },
        [FPR32, FPR32] => UnaF32 {
            insts: [
                FMov32R,
                // FRInt: A I M N P X Z
                FRIntA32, FRIntI32, FRIntM32, FRIntN32, FRIntP32, FRIntX32, FRIntZ32,
                FRInt32X32, FRIntZ32X32, FRInt64X32, FRIntZ64X32,
                // Floating Arithmetic with unary source
                FAbs32, FNeg32, FSqrt32,
                // MIR pseudo-instructions
                LoadStackPosF32, StoreStackPosF32
            ],
        },
        [FPR32, FPR64] => UnaryF32F64 { insts: [ FCvt32F64 ] },
        [FPR64, FPR32] => UnaryF64F32 { insts: [ FCvt64F32 ] },

        [FPR64, ImmFMov64] => FMov64I { insts: [ FMov64I ] },
        [FPR32, ImmFMov32] => FMov32I { insts: [ FMov32I ] },
    }
}

template[T, U] TenaryOP {
    out: { rd: T, },
    in: { rn: U, rm: U, rs: T, };

    impl {
        [GPR64, GPR64] => TenaryG64 { insts: [ MAdd64, MSub64 ] },
        [GPR64, GPR32] => TenaryG64G32 {
            insts: [ SMAddL, SMSubL, UMAddL, UMSubL ],
        },
        [GPR32, GPR32] => TenaryG32 { insts: [ MAdd32, MSub32 ] },

        [FPR64, FPR64] => TenaryF64 {
            insts: [ FMAdd64, FMSub64, FNMAdd64, FNMSub64 ]
        },
        [FPR32, FPR32] => TenaryF32 {
            insts: [ FMAdd32, FMSub32, FNMAdd32, FNMSub32 ]
        },
    }
}

template[Dst] LoadRRR {
    out: { rd: Dst, },
    in: { rn: GPR64, rm: GPR64, },
    props: {
        rm_op: Option<RegOP> = None;
    };

    impl {
        [GPR64] => LoadGr64 {
            insts: [
                LdrGr64, LdrBGr64, LdrHGr64, LdrSBGr64, LdrSHGr64,
            ],
        },
        [GPR32] => LoadGr32 {
            insts: [
                LdrGr32, LdrBGr32, LdrHGr32, LdrSBGr32, LdrSHGr32,
            ],
        },
        [FPR64] => LoadF64 { insts: [ LdrF64 ] },
        [FPR32] => LoadF32 { insts: [ LdrF32 ] },
    }
}

template[Src] StoreRRR {
    in: { rd: Src, rn: GPR64, rm: GPR64, },
    props: {
        rm_op: Option<RegOP> = None;
    };

    impl {
        [GPR64] => StoreGr64 {
            insts: [ StrGr64, StrBGr64, StrHGr64, ],
        },
        [GPR32] => StoreGr32 {
            insts: [ StrGr32, StrBGr32, StrHGr32, ],
        },
        [FPR64] => StoreF64 { insts: [ StrF64 ] },
        [FPR32] => StoreF32 { insts: [ StrF32 ] },
    }
}

template[Dst, Offset] LoadRRIBaseOffset {
    out: { rd: Dst, },
    in:  { rn: GPR64, rm: Offset, };

    impl {
        [GPR64, ImmLSP64] => LoadGr64Base {
            insts: [
                LdrGr64Base, LdrBGr64Base, LdrHGr64Base, LdrSBGr64Base, LdrSHGr64Base,
            ],
        },
        [GPR32, ImmLSP32] => LoadGr32Base {
            insts: [
                LdrGr32Base, LdrBGr32Base, LdrHGr32Base, LdrSBGr32Base, LdrSHGr32Base,
            ],
        },
        [FPR64, ImmLSP64] => LoadF64Base { insts: [ LdrF64Base ] },
        [FPR32, ImmLSP32] => LoadF32Base { insts: [ LdrF32Base ] },

        // ImmLSPXX 操作数只能表示整数而不能表示符号偏移量, 因此这里多加四组符号偏移量的指令.
        //
        // #### 为什么不就地计算偏移量然后使用 ImmLSPXX 呢?
        //
        // Remusys-MIR 系统自己也有优化 pass, 难免会在 MIR 中添加或者删除指令.
        // 这样就会导致原本的偏移量计算不再正确, 因此需要使用符号偏移量来保证正确性.
        //
        // 汇编语法:
        //
        // * `<opcode> <rd>, [<rn>, :lo12:<symbol>]`
        //
        // 计算公式:
        //
        // * `address = <rn> + <symbol>[:lo12]`
        [GPR64, Symbol] => LoadGr64BaseS {
            insts: [
                LdrGr64BaseS, LdrBGr64BaseS, LdrHGr64BaseS, LdrSBGr64BaseS, LdrSHGr64BaseS,
            ],
        },
        [GPR32, Symbol] => LoadGr32BaseS {
            insts: [
                LdrGr32BaseS, LdrBGr32BaseS, LdrHGr32BaseS, LdrSBGr32BaseS, LdrSHGr32BaseS,
            ],
        },
        [FPR64, Symbol] => LoadF64BaseS { insts: [ LdrF64BaseS ] },
        [FPR32, Symbol] => LoadF32BaseS { insts: [ LdrF32BaseS ] },
    }
}

template[Src, Offset] StoreRRIBaseOffset {
    in: { rd: Src, rn: GPR64, rm: Offset, };

    impl {
        [GPR64, ImmLSP64] => StoreGr64Base {
            insts: [
                StrGr64Base, StrBGr64Base, StrHGr64Base,
            ],
        },
        [GPR32, ImmLSP32] => StoreGr32Base {
            insts: [
                StrGr32Base, StrBGr32Base, StrHGr32Base,
            ],
        },
        [FPR64, ImmLSP64] => StoreF64Base { insts: [ StrF64Base ] },
        [FPR32, ImmLSP32] => StoreF32Base { insts: [ StrF32Base ] },

        // 符号偏移量的存储指令
        [GPR64, Symbol] => StoreGr64BaseS {
            insts: [
                StrGr64BaseS, StrBGr64BaseS, StrHGr64BaseS,
            ],
        },
        [GPR32, Symbol] => StoreGr32BaseS {
            insts: [
                StrGr32BaseS, StrBGr32BaseS, StrHGr32BaseS,
            ],
        },
        [FPR64, Symbol] => StoreF64BaseS { insts: [ StrF64BaseS ] },
        [FPR32, Symbol] => StoreF32BaseS { insts: [ StrF32BaseS ] },
    }
}

template[Dst, Offset] LoadRRIndexed {
    out: {
        rd: Dst, 
        rn: GPR64, // in-out registers are stored in the output
    },
    in: { rm: Offset, },
    props: {
        addr_mode: AddrMode = AddrMode::PostIndex;
    },
    init: {
        super::utils::mark_operand_used(ret.rd());
    };

    impl {
        [GPR64, ImmLSP64] => LoadGr64Indexed {
            insts: [
                LdrGr64Indexed, LdrBGr64Indexed, LdrHGr64Indexed,
                LdrSBGr64Indexed, LdrSHGr64Indexed,
            ],
        },
        [GPR32, ImmLSP32] => LoadGr32Indexed {
            insts: [
                LdrGr32Indexed, LdrBGr32Indexed, LdrHGr32Indexed,
                LdrSBGr32Indexed, LdrSHGr32Indexed,
            ],
        },
        [FPR64, ImmLSP64] => LoadF64Indexed { insts: [ LdrF64Indexed ] },
        [FPR32, ImmLSP32] => LoadF32Indexed { insts: [ LdrF32Indexed ] },
    }
}

template[Src, Offset] StoreRRIndexed {
    out: {
        rn: GPR64, // in-out registers are stored in the output
    },
    in: { rd: Src, rm: Offset, },
    props: {
        addr_mode: AddrMode = AddrMode::PostIndex;
    };

    impl {
        [GPR64, ImmLSP64] => StoreGr64Indexed {
            insts: [
                StrGr64Indexed, StrBGr64Indexed, StrHGr64Indexed,
            ],
        },
        [GPR32, ImmLSP32] => StoreGr32Indexed {
            insts: [
                StrGr32Indexed, StrBGr32Indexed, StrHGr32Indexed,
            ],
        },
        [FPR64, ImmLSP64] => StoreF64Indexed { insts: [ StrF64Indexed ] },
        [FPR32, ImmLSP32] => StoreF32Indexed { insts: [ StrF32Indexed ] },
    }
}

template[Dst] LoadLiteral {
    out: { rd: Dst, },
    in: { from: Symbol, };
    impl {
        [GPR64] => LoadGr64Literal {
            insts: [
                LdrGr64Literal, LdrBGr64Literal, LdrHGr64Literal,
                LdrSBGr64Literal, LdrSHGr64Literal,
            ]
        },
        [GPR32] => LoadGr32Literal {
            insts: [
                LdrGr32Literal, LdrBGr32Literal, LdrHGr32Literal,
                LdrSBGr32Literal, LdrSHGr32Literal,
            ]
        },
        [FPR64] => LoadF64Literal { insts: [ LdrF64Literal ] },
        [FPR32] => LoadF32Literal { insts: [ LdrF32Literal ] },
    }
}

template[Dst] MirLoadLiteral {
    out: {
        dst: Dst, 
        // Temporary address register for loading the literal.
        tmp_addr: GPR64,
    },
    in: { src: Symbol, };

    impl {
        [GPR64] => MirLdrLitG64 { insts: [ MirLdrLitG64 ], },
        [GPR32] => MirLdrLitG32 { insts: [ MirLdrLitG32 ], },
        [FPR64] => MirLdrLitF64 { insts: [ MirLdrLitF64 ], },
        [FPR32] => MirLdrLitF32 { insts: [ MirLdrLitF32 ], },
    }
}

// AArch64 没有与 Load Literal 相近的 Store Literal 模式.
// 这里的 Store Literal 是一个 MIR 伪指令, 用于将一个常量存储到指定的符号地址.
template[Src] MirStoreLiteral {
    out: { tmp_addr: GPR64, },
    in: { rd: Src, to: Symbol, };
    impl {
        [GPR64] => MirStrLitG64 { insts: [ MirStrLitG64 ], },
        [GPR32] => MirStrLitG32 { insts: [ MirStrLitG32 ], },
        [FPR64] => MirStrLitF64 { insts: [ MirStrLitF64 ], },
        [FPR32] => MirStrLitF32 { insts: [ MirStrLitF32 ], },
    }
}

template[Src, Offset] MirStoreImm {
    in: {
        imm: Src,
        base: GPR64,
        offset: Offset,
    },
    out: { tmpreg: GPR64, };
    impl {
        [Imm64,  ImmLSP64] => MirStImm64 { insts: [ MirStImm64 ], },
        [Symbol, ImmLSP64] => MirStSym64 { insts: [ MirStSym64 ], },
        [Imm32,  ImmLSP32] => MirStImm32 { insts: [ MirStImm32 ], },
    }
}

template[Dst, Src] MirLoadConst {
    out: { rd: Dst, },
    in: { src: Src, };

    impl {
        [GPR64, Imm64] => LoadConst64 { insts: [ LoadConst64 ], },
        [GPR64, Symbol] => LoadConst64Symbol { insts: [ LoadConst64Symbol ], },
    }
}

template[Dst, Src] MirLoadFImm {
    out: {
        rd: Dst,
        tmpreg: GPR64,
    },
    in: { src: Src, };

    impl {
        [FPR64, Imm64] => MirLdImmF64 { insts: [ MirLdImmF64 ], },
        [FPR32, Imm32] => MirLdImmF32 { insts: [ MirLdImmF32 ], },
    }
}

template[T] CondSelects {
    out: { rd: T, },
    in: {
        rn: T,
        rm: T,
        csr: PState,
    },
    props: {
        cond: MirCondFlag = MirCondFlag::AL;
    };

    impl {
        [GPR64] => CSel64 {
            insts: [ CSel64, CSInc64, CSInv64, CSNeg64 ],
        },
        [GPR32] => CSel32 {
            insts: [ CSel32, CSInc32, CSInv32, CSNeg32 ],
        },
        [FPR64] => CSelF64 { insts: [ CSelF64 ], },
        [FPR32] => CSelF32 { insts: [ CSelF32 ], },
    }
}

template[T] CondSets {
    out: { rd: T, },
    in: {
        csr: PState,
    },
    props: {
        cond: MirCondFlag = MirCondFlag::AL;
    };

    impl {
        [GPR64] => CSet64 { insts: [ CSet64 ], },
        [GPR32] => CSet32 { insts: [ CSet32 ], },
    }
}
